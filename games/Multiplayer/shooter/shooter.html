<html>

<head>
    <meta charset="UTF-8" />
    <title>Multiplayer Experiment</title>
    <!-- Load the Phaser game library -->
    <script src="//cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser.js"></script>

</head>

<body>
    <script src="/socket.io/socket.io.js"></script>
    <script type="text/javascript">
        let config = {
            // 오토로 캔버스 만들어줌
            type: Phaser.AUTO,
            // 위 아래 크기 조정
            width: 800,
            height: 600,

            physics: {
                default: 'arcade',
                arcade: {
                    gravity: {
                        y: 0
                    }
                }
            },
            // 사용하는 신 지정
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        let game = new Phaser.Game(config);

        let player;
        //이동 관련
        let cursors;
        // 공격 관련
        let bullet;

        // 현재 상태 모두 저장하는 변수
        let self;


        function preload() {
            this.load.image('tile', 'assets/tile.png');
            this.load.image('bullet', 'assets/bullet.png');
            this.load.image('tank', 'assets/tank.png');
            this.load.image('otherPlayer', 'assets/tank_red.png');
        }

        function create() {
            this.add.tileSprite(0, 0, config.width, config.height, 'tile').setOrigin(0, 0);

            // 화살표와 wasd 모두 사용할 수 있도록 설정
            cursors = this.input.keyboard.addKeys({
                'up1': Phaser.Input.Keyboard.KeyCodes.UP,
                'up2': Phaser.Input.Keyboard.KeyCodes.W,
                'down1': Phaser.Input.Keyboard.KeyCodes.DOWN,
                'down2': Phaser.Input.Keyboard.KeyCodes.S,
                'left1': Phaser.Input.Keyboard.KeyCodes.LEFT,
                'left2': Phaser.Input.Keyboard.KeyCodes.A,
                'right1': Phaser.Input.Keyboard.KeyCodes.RIGHT,
                'right2': Phaser.Input.Keyboard.KeyCodes.D,
                'space': Phaser.Input.Keyboard.KeyCodes.SPACE,
                'shift': Phaser.Input.Keyboard.KeyCodes.SHIFT
            });

            bullets = this.physics.add.group();

            // 플레이어 생성(맵 가운데)
            player = this.physics.add.sprite(Math.random() * config.width, Math.random() * config.height, 'tank').setDisplaySize(42, 46);
            player.setCollideWorldBounds(true);

            // 소켓을 설정함
            this.socket = io();


            // 맵 모든 영역을 클릭하면 반응하도록 해주는 함수
            this.input.on('pointerdown', function() {
                // 방향 및 속도 계산 함수
                var start_x = Math.cos(player.rotation + Math.PI / 2) * 30;
                var start_y = Math.sin(player.rotation + Math.PI / 2) * 30;

                // 방향 및 속도 계산 함수
                var speed_x = Math.cos(player.rotation + Math.PI / 2) * 300;
                var speed_y = Math.sin(player.rotation + Math.PI / 2) * 300;
                // bullet 만들어서 발사함
                let bullet = bullets.create(player.x + start_x, player.y + start_y, 'bullet');
                bullet.setCollideWorldBounds(false);
                bullet.setVelocity(speed_x, speed_y);

                // 내일은 총알부터
                //https://code.tutsplus.com/tutorials/create-a-multiplayer-pirate-shooter-game-in-your-browser--cms-23311
                // 4.Syncing Bullets 부터 시작하면 됨
            });

            // 내가 접속해서 만들어지는 정보 보내기
            this.socket.emit('new-player', {
                x: player.x,
                y: player.y,
                rotation: player.rotation
            });

            // 현재 상태에 다른 플레이어를 담을 수 있는 그룹 만들기 
            this.otherPlayers = this.physics.add.group();
            // this 상태 self 변수에 저장
            self = this;

            // 내가 접속할 때 만들어져있는 모든 플레이어의 정보 가져옴
            this.socket.on('currentPlayers', function(players) {
                Object.keys(players).forEach(function(id) {
                    if (players[id].playerId === self.socket.id) {} else { // 나를 제외한 다른 사람들을 저장하는 함수 사용
                        addOtherPlayers(self, players[id]);
                    }
                });
            });

            // 새로운 클라이언트 접속이 생겼을 때 또 다시 추가
            this.socket.on('create-newplayer', function(playerInfo) {
                addOtherPlayers(self, playerInfo);
            });

            // 접속이 끊어진 클라이언트는 지우기
            this.socket.on('disconnect', function(playerId) {
                self.otherPlayers.getChildren().forEach(function(otherPlayer) {
                    if (playerId === otherPlayer.playerId) {
                        otherPlayer.destroy();
                    }
                });
            });

            this.socket.on('playerMoved', function(playerInfo) {
                self.otherPlayers.getChildren().forEach(function(otherPlayer) {
                    if (playerInfo.playerId === otherPlayer.playerId) {
                        otherPlayer.setRotation(playerInfo.rotation);
                        otherPlayer.setPosition(playerInfo.x, playerInfo.y);
                    }
                });
            });

        }

        // 다른 사람들 정보 저장하는 함수
        function addOtherPlayers(self, playerInfo) {
            // 다른 사람들의 x/y 좌표를 가져와서 다른 색깔로 만들기
            const otherPlayer = self.add.sprite(playerInfo.x, playerInfo.y, 'otherPlayer').setDisplaySize(42, 46);
            // id 는 소켓 id 저장
            otherPlayer.playerId = playerInfo.playerId;
            // 추가하기
            self.otherPlayers.add(otherPlayer);
        }


        function update() {
            // 좌우 컨트롤
            if (cursors.left1.isDown || cursors.left2.isDown) {
                player.setVelocityX(-150);
            } else if (cursors.right1.isDown || cursors.right2.isDown) {
                player.setVelocityX(150);
            } else {
                player.setVelocityX(0);
            }

            // 상하 컨트롤
            if (cursors.up1.isDown || cursors.up2.isDown) {
                player.setVelocityY(-150);
            } else if (cursors.down1.isDown || cursors.down2.isDown) {
                player.setVelocityY(150);
            } else {
                player.setVelocityY(0);
            }

            // 유저의 뱃머리를 마우스 커서 위치로 항상 돌아가도록 설정
            player.rotation = (Phaser.Math.Angle.Between(player.x, player.y, this.input.mousePointer.x, this.input.mousePointer.y) - 1.6);

            // emit player movement
            var x = player.x;
            var y = player.y;
            var r = player.rotation;
            if (player.oldPosition && (x !== player.oldPosition.x || y !== player.oldPosition.y || r !== player.oldPosition.rotation)) {
                this.socket.emit('playerMovement', {
                    x: player.x,
                    y: player.y,
                    rotation: player.rotation
                });
            }

            // save old position data
            player.oldPosition = {
                x: player.x,
                y: player.y,
                rotation: player.rotation
            };
        }
    </script>


</body>

</html>